#ifndef _lab_activity_Activity_hpp_
#define _lab_activity_Activity_hpp_

#include "lab/Exception.hpp"
#include "lab/event/Event.hpp"
#include "lab/event/Listener.hpp"
#include "lab/Engine.hpp"
#include "lab/activity/Binder.hpp"
#include "lab/graphic/Renderer.hpp"


namespace lab {

class Engine;

/*!
 * \brief The namespace containing classes relatives to the Activity class.
 *
 * The Activity class is the main class that the final user of the labengine will use.
 * Indeed, it is it that will make the link between the Engine and the Game.
 * The Activity class is specialy designed to build a clear game structure.
 */
namespace activity {

/*!
 * \brief An activity represents a single part of a game, like a splash screen.
 *
 * This is the main object of the end user of the library. It is where the adventure start.
 * An activity is a single part of the game. An activity can call an other activity, using differents kind of strategies
 * provided by the engine.
 * 
 */
class Activity : public event::Listener {

	protected:
		bool mInitialized;

		Engine* mEngine;

		Binder mBinder;
		graphic::Renderer* mRenderer;

	public:
		/*!
		 * \brief Activity constructor.
		 * \param name The Activity's name.
		 * \param engine The Engine that make this Activity running.
		 * \param model A pointer to the Model the activity will use.
		 */
		Activity (Engine* engine);

		/*!
		 * \brief Activity destructor.
		 */
		virtual ~Activity ();

		/*!
		 * \brief Get a pointer to the Engine that is running this Activity.
		 * \return A pointer to the Engine.
		 */
		Engine* getEngine () const {return mEngine;}

		/*!
		 * \brief Initialize the Activity and its components (Model, Binders).
		 * \param init_values A value's map (to transmits values from activity to activity).
		 *
		 * This function will be launched by the Engine at the initializing state of the Engine or when an other activity
		 * request this one to be launched.
		 * Inherited Activities should overwrite this one with their own methods, and call parent method : Activity::initialize (...).
		 */
		virtual void initialize () throw (lab::Exception);

		/*!
		 * \brief Say if the Activity is initalized or not.
		 */
		bool isInitialized () const {return mInitialized;}

		/*!
		 * \brief Shutdown the Activity.
		 *
		 * This function will unitialized the activity (freeing the model and more).
		 * It will be called when the Engine have the order to change the Activity and delete the last, or at the
		 * Engine shutdown.
		 */
		virtual void shutdown ();

		/*!
		 * \brief The Activity's cycle method.
		 *
		 * The cycle method is executed each Engine's loop.
		 */
		virtual void cycle () = 0;
		
		/*!
		 * \brief The Activity update method.
		 *
		 * This method will update the position of all the things.
		 * This method must be the only one from where new drawables will be created (to avoid rendering segfault adding
		 * a new Drawable in a renderer which render).
		 */
		virtual void update () = 0;
		 
		/*!
		 * \brief The Activity render method.
		 *
		 * This method is dedicated to render the game.
		 */
		virtual void render () = 0;

		/*!
		 * \brief Handle the events coming from the differents Input Devices (send them to the Binder).
		 * \param event The Event generated by the Device that notified this Activity.
		 */
		void notify (const event::Event& event);
		
		/*!
		 * \brief Return the renderer.
		 */
		graphic::Renderer* getRenderer () const {return mRenderer;}
};

}}

#endif

